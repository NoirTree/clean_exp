"""
Generate some fake valid and invalid data.
"""
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import random
import string

from faker import Faker
import dataprep.clean

# zh_CN, en_US
fake = Faker()

## address
Faker.seed(0)

def find_invalid_address(num=30):
    """返回所有validate识别不出的address"""
    _df = pd.DataFrame(columns=["address"])
    for i in range(num):
        _df.loc[i] = [fake.address()] # 使用iloc会导致越界; 用loc则会被认为是添加行
    return _df[validate_address(_df["address"])==False]

def find_valid_address(num=30):
    """返回所有validate可以识别的address"""
    _df = pd.DataFrame(columns=["address"])
    for i in range(num):
        _df.loc[i] = [fake.address()]
    return _df[validate_address(_df["address"])]

len(find_valid_address(500))/500 # 89%

# 是否将\n换成, 就好了
temp = find_invalid_address().iat[0, 0]
temp.replace("\n", ", ")
validate_address(temp.replace("\n", ", ")) # 还是不行......



## phone number
Faker.seed(0)

_df = pd.DataFrame(columns=("phone", "msisdn"))
for i in range(30):
    _df.loc[i] = [fake.phone_number(), fake.msisdn()]

_df
validate_phone(_df['phone'])
validate_phone(_df['msisdn']) # 不支持

def find_invalid_phone(num=30):
    _df = pd.DataFrame(columns=["phone"])
    for i in range(num):
        _df.loc[i] = [fake.phone_number()]
    return _df[validate_phone(_df["phone"])==False]

def find_valid_phone(num=30):
    _df = pd.DataFrame(columns=["phone"])
    for i in range(num):
        _df.loc[i] = [fake.phone_number()]
    return _df[validate_phone(_df["phone"])]

find_valid_phone()
len(find_valid_phone(500))/500 # 79%
find_invalid_phone()



## email--都没问题
Faker.seed(0)

fake.unique.free_email_domain()

_df = pd.DataFrame(columns=(
    "email",
    "ascii_company_email",
    "ascii_email",
    "ascii_free_email",
    "ascii_safe_email",
    "company_email",
    "free_email",
    )
)

n_row=30
for i in range(n_row):
    _df.loc[i] = [
        fake.email(),
        fake.ascii_company_email(),
        fake.ascii_email(),
        fake.ascii_free_email(),
        fake.ascii_safe_email(),
        fake.company_email(),
        fake.free_email(),
    ]

_df

for i in range(len(_df.columns)):
    if validate_email(_df.iloc[:, i]).sum()!=n_row:
        print("when checking %d, something goes wrong." % i)


## ip--都没问题
def generate_valid_ip(n=500, seed=0):
    Faker.seed(seed)
    _df = pd.DataFrame(columns=("ipv4", "ipv6"))
    for i in range(n):
        _df.loc[i] = [fake.ipv4(), fake.ipv6()]
    return _df

df_ip = generate_valid_ip()
validate_ip(df_ip.iloc[:, 0]).sum()
validate_ip(df_ip.iloc[:, 1]).sum()




## generate negative values (credit: AutoType)

# function to calculate the invalid data ratio generated by `layer_func`
def cal_invalid_rate(srs, layer_func, chars_set, validate_func, n_run=10):
    """
    calculate the ratio of invalid data generated by mutation.
    :param srs: np.Series. Original valid data
    :param layer_func: Function. Element-wise mutation function. return a mutated string.
    :param chars_set: Set. Characters used for replacement. Will be passed to layer_func.
    :param validate_func: Function. return T or F.
    :param n_run: int. Run how many time to calculate the average invalid ratio.
        (default: 10)

    :return: float. The average invalid ratio.
    """
    n_row = len(srs)
    invalid_rate = 0
    for _ in range(n_run):
        srs_invalid = srs.apply(lambda x: layer_func(x, chars_set))
        invalid_rate += np.divide(n_row - validate_func(srs_invalid).sum(), n_row)
    return invalid_rate/n_run

# layer 1 mutation: supplant in-alpha non-punctual character with in-alpha non-punctual one
def layer1_replace_non_punctua(s, non_punctua_chars_set, rate=0.5):
    '''for each mutatable place, mutate with a fixed rate'''
    s_lst = list(s)
    cands = list(non_punctua_chars_set)
    for i in range(len(s_lst)):
        if s_lst[i] in non_punctua_chars_set:
            prob = random.random() # but not include 1
            if prob <= rate: # replace
                s_lst[i] = random.choice(cands)
    return "".join(s_lst)

# layer 2 mutation: supplant in-alpha character with in-alpha one
def layer2_replace_punctua(s, punctua_chars_set, rate=0.5):
    '''for each mutatable place, mutate with a fixed rate'''
    s_lst = list(s) # turn the string into a list
    cands = list(punctua_chars_set)
    for i in range(len(s_lst)):
        if s_lst[i] in punctua_chars_set:
            prob = random.random() # but not include 1
            if prob <= rate: # replace
                s_lst[i] = random.choice(cands)
    return "".join(s_lst)

# layer 3 mutation: replace in-alpha character with in-alpha one
def layer3_replace_punctua_with_dict(s, punctua_chars_set, rate=0.5):
    '''for each mutatable place, mutate with a fixed rate'''
    s_lst = list(s) # turn the string into a list
    cands = list(string.ascii_letters)
    for i in range(len(s_lst)):
        if s_lst[i] in punctua_chars_set:
            prob = random.random() # but not include 1
            if prob <= rate: # replace
                s_lst[i] = random.choice(cands)
    return "".join(s_lst)

# layer 3 plus: candidate=English alphabet UNION in-alpha chars
def layer3_plus(s, punctua_chars_set, rate=0.5):
    '''for each mutatable place, mutate with a fixed rate'''
    s_lst = list(s) # turn the string into a list
    cands = list(set(string.ascii_letters).union(punctua_chars_set))
    for i in range(len(s_lst)):
        if s_lst[i] in punctua_chars_set:
            prob = random.random() # but not include 1
            if prob <= rate: # replace
                s_lst[i] = random.choice(cands)
    return "".join(s_lst)


# ipv4 layer1 mutation
# validate_ip能检测出的layer1产生的invalid有72%
srs_ipv4 = df_ip["ipv4"]
srs_ipv4_ele = srs_ipv4.apply(set)
in_alphabet_chars_ipv4 = set()
srs_ipv4_ele.apply(lambda x:in_alphabet_chars_ipv4.update(x))
in_alphabet_chars_ipv4

non_punctua_chars_ipv4 = {x for x in in_alphabet_chars_ipv4
                          if x.isalpha() or x.isnumeric()}
non_punctua_chars_ipv4

# test
temp = srs_ipv4[0]
layer1_replace_non_punctua(temp, non_punctua_chars_ipv4)

# calculate invalid ratio
cal_invalid_rate(srs_ipv4, layer1_replace_non_punctua, non_punctua_chars_ipv4, validate_ip)


# ipv6: layer1无法产生invalid
srs_ipv6 = df_ip["ipv6"]
srs_ipv6_ele = srs_ipv6.apply(set)
in_alphabet_chars_ipv6 = set()
srs_ipv6_ele.apply(lambda x:in_alphabet_chars_ipv6.update(x))
in_alphabet_chars_ipv6

non_punctua_chars_ipv6 = {x for x in in_alphabet_chars_ipv6
                          if x.isalpha() or x.isnumeric()}
non_punctua_chars_ipv6

temp = srs_ipv6[0]
layer1_replace_non_punctua(temp, non_punctua_chars_ipv6)

cal_invalid_rate(srs_ipv6, layer1_replace_non_punctua, non_punctua_chars_ipv6, validate_ip)


# layer 2
# 对ipv6有用，几乎100%
layer2_replace_punctua(temp, in_alphabet_chars_ipv6)
cal_invalid_rate(srs_ipv6,
                 layer2_replace_punctua,
                 in_alphabet_chars_ipv6,
                 validate_ip)

# 对ipv4也几乎100%
cal_invalid_rate(srs_ipv4,
                 layer2_replace_punctua,
                 in_alphabet_chars_ipv4,
                 validate_ip)


## 测试mutate email
Faker.seed(0)

srs_email = pd.Series(name="email", dtype=object)

n_row=500
for i in range(n_row):
   srs_email.loc[i] = fake.email()

in_alphabet_chars_email = set()
srs_email.apply(set).apply(lambda x:in_alphabet_chars_email.update(x))
in_alphabet_chars_email
non_punctua_chars_email = {x for x in in_alphabet_chars_email
                            if x.isalpha() or x.isnumeric()}
non_punctua_chars_email
in_alphabet_chars_email-non_punctua_chars_email # {'-', '.', '@'}

# layer 1: incapable (0%)
temp = srs_email[0]
layer1_replace_non_punctua(temp, non_punctua_chars_email)

cal_invalid_rate(srs_email,
                 layer1_replace_non_punctua,
                 non_punctua_chars_email,
                 validate_email)

# layer2: 76%~77%
temp = srs_email[0]
layer2_replace_punctua(temp, in_alphabet_chars_email)

cal_invalid_rate(srs_email,
                 layer2_replace_punctua,
                 in_alphabet_chars_email,
                 validate_email)
# layer3: 74%
layer3_replace_punctua_with_dict(temp, in_alphabet_chars_email)
cal_invalid_rate(srs_email,
                 layer3_replace_punctua_with_dict,
                 in_alphabet_chars_email,
                 validate_email)

# layer3_plus: 76%
layer3_plus(temp, in_alphabet_chars_email)
cal_invalid_rate(srs_email,
                 layer3_plus,
                 in_alphabet_chars_email,
                 validate_email)

